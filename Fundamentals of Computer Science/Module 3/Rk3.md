% Рубежный контроль № 3: конспект по скриптовому языку
% 06.01.2025
% Степан Чекунов, ИУ9-11Б

## 1. Типизация и система типов языка

### 1. Типизация
* Динамическая - тип переменной определяется в процессе выполнения программы.
* Строгая - невозможность выполнения неявных преобразований типов данных.
* Неявная - при объявлении переменной не нужно указывать тип, к которому она принадлежит.

### 2. Типы данных

#### 1. Логический 
* этот тип данных содержит всего две булевых константы: True и False

#### 2. Числовой
\begin{center}
\begin{tabular}{|c|c|}
\hline
\textbf{Тип} & \textbf{Что представляет}  \\
\hline
int          & целые числа                \\
\hline
float          & десятичные числа         \\
\hline
complex         & комплексные числа        \\
\hline
\end{tabular}
\end{center}

#### 3. Строки 
* текст произвольной длины, взятый в одинарные, двойные или тройные кавычки

> _Строки также являются неизменяемым типом данных, хотя получить доступ к 
символу строки можно по его индексу_

#### 4. Списки 
* упорядоченные неименованные изменяемые коллекции значений

#### 5. Кортежи 
* упорядоченные неименованные неизменяемые коллекции значений

#### 6. Множества 
* неименованные и неупорядоченные изменяемые коллекции уникальных и неизменяемых значений

#### 7. Словари 
* именованные изменяемые неупорядоченные коллекции значений

#### 8. NoneType 
* специальное значение None, которое означает отсутствие значения

#### 9. Байтовый
*  упорядоченная неизменяемая последовательность отдельных байтов

## 2. Основные управляющие конструкции

Условный оператор if, цикл for, цикл while, def - начало объявления функции, 
try/expect - перехват исключений

## 3. Подмножество языка для функционального программирования: 
> способы обеспечить иммутабельность данных там, где это необходимо, 
функции как объекты 1-го класса, функции высших порядков, 
встроенные функции высших порядков для работы с последовательностями.

#### 1. Иммутабельностью, т.е. невозможностью изменения после создания, обладают следующие объекты
    tuple
    str
    int
    float
    complex
    bytes
    frozenset(неизменяемая версия set)
Способы обеспечить иммутабельность

* Метод \_\_new__ в классах
* Метод \_\_slots__ в классах
* С помощью модуля dataclasses можно создавать иммутабельные классы, устанавливая параметр frozen=True
* С помощью модуля typing можно создать иммутабельные кортежи с аннотациями типов.

#### 2. Функциии, как объекты 1-го класса
> В Python функции являются объектами первого класса, что означает, 
что они могут

* Быть присвоенны переменным
* Передаваться в качестве аргументов другим функциям
* Возвращаться из других функций

```python
#Пример присвоения функции переменной
def a():
  print("BMSTU")
  
var=a

var() #BMSTU
```

#### 3. Функции, высших порядков
> Функции высших порядков - функции, которые принимают другие функции
в качестве аргумента или возвращают функции в качестве аргумента.

```python
#Пример
def higher_order(function):  # функция высшего порядка
    return function(15)

def multiply(x): # функция первого порядка
    return x * x
```

#### 4. Встроенные функции высших порядков для работы с последовательностями
\begin{center}
\begin{tabular}{|c|c|}
\hline
\textbf{Функция} & \textbf{Что делает}  \\
\hline
map()          & принимает функцию-аргумент и применяет её ко всем элементам последовательности\\
\hline
filter()          & фильтрует последовательность по заданному условию        \\
\hline
reduce()         & кумулятивно применяет функцию к элементам последовательности        \\
\hline
zip()         & принимает несколько итерируемых объектов, из которых поэлементно создаёт кортежи\\
\hline
\end{tabular}
\end{center}

## 4. Синтаксис простых классов и особенности ООП
> Пример простого класса
```python
class Complex:
    def __init__(self, realpart, imagpart):
        self.r = realpart
        self.i = imagpart
```
> Динамическое изменение классов

> Методы класса - выполняются в контексте самого класса

> Метод деструктор \_\_del__


## 5. Важнейшие функции для работы с потоками ввода/вывода, строками, регулярными выражениями.

#### 1. Поток ввода/вывода

\begin{center}
\begin{tabular}{|c|c|}
\hline
\textbf{Функция} & \textbf{Что делает}  \\
\hline
print()         & выводит значения               \\
\hline
input()          & получает вводимые пользователем строки       \\
\hline
\end{tabular}
\end{center}

#### 2. Строки

\begin{center}
\begin{tabular}{|c|c|}
\hline
\textbf{Функция} & \textbf{Что делает}  \\
\hline
split()         & разбивает строку на список подстрок, по заданному разделителю               \\
\hline
join()         & объединяет элементы списка в строку с использованием данного разделителя      \\
\hline
replace()         & заменяет все вхождения одной строки на другую      \\
\hline
find()         & возвращает индекс первого вхождения подстроки, или -1, если строка не найдена      \\
\hline
\end{tabular}
\end{center}

#### 3. Регулярные выражения

\begin{center}
\begin{tabular}{|c|c|}
\hline
\textbf{Функция} & \textbf{Что делает}  \\
\hline
re.search()         & ищет первое вхождение шаблона в строке              \\
\hline
re.sub()          & заменяет все вхождения шаблона на заданную строку      \\
\hline
re.split()          & разбивает строку по шаблону      \\
\hline
\end{tabular}
\end{center}